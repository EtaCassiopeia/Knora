@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._
@import org.knora.webapi.twirl.SparqlTemplateLinkUpdate
@import org.knora.webapi.messages.v1respondermessages.valuemessages._

@**
 * Generates statements to be added to the INSERT clause of a SPARQL update when creating a new value of a resource
 * property (as opposed to a new version of an existing value).
 *
 * @param valueIndex the index of the value in the sequence of values that are being created in the transaction (can
 *                   be 0 if only one value is being created). This index will be used to make SPARQL variable names
 *                   (except `?resource`) specific to the value being created.
 * @param value the value to insert.
 * @param linkUpdates a list of [[LinkUpdate]] objects describing links and LinkValues that need to be
 *        updated for resource references in Standoff text values.
 * @param maybeComment an optional comment on the value.
 * @param permissionRelevantAssertions Permission-relevant assertions, i.e. owner and project plus permissions, in
 *        the form of a list of tuples (predicate, object).
 *
 * The expected SPARQL variables are those generated by generateWhereStatementsForCreateValue.scala.txt, plus
 * ?resource and ?currentTime.
 *@
@(valueIndex: Int,
  value: UpdateValueV1,
  linkUpdates: Seq[SparqlTemplateLinkUpdate],
  maybeComment: Option[String],
  permissionRelevantAssertions: Seq[(IRI, IRI)])

@* Construct the value. *@
?newValue@valueIndex rdf:type ?valueType@valueIndex .

@value match {
    case textValue: TextValueV1 => {

        ?newValue@valueIndex knora-base:valueHasString """@textValue.utf8str""" .

        @* Create a Standoff node for each StandoffPositionV1. *@

        @for((attribute, position) <- textValue.flattenStandoff) {
            ?newValue@valueIndex knora-base:valueHasStandoff
                [
                    @*

                    If the StandoffPositionV1 contains both a resid and an href, we assume that the href is
                    redundant (i.e. it's based on the resid), so we ignore it.

                    *@
                    @(position.resid, position.href) match {
                        case (Some(resid), _) => {
                            rdf:type knora-base:StandoffLink ;
                            knora-base:standoffHasAttribute "@attribute" ;
                            knora-base:standoffHasLink <@resid> ;
                        }

                        case (None, Some(href)) => {
                            rdf:type knora-base:StandoffHref ;
                            knora-base:standoffHasAttribute "@attribute" ;
                            knora-base:standoffHasHref <@href> ;
                        }

                        case (None, None) => {
                            rdf:type knora-base:StandoffVisualAttribute ;
                            knora-base:standoffHasAttribute "@attribute" ;
                        }
                    }

                    knora-base:standoffHasStart @position.start ;
                    knora-base:standoffHasEnd @position.end
                ] .
        }
    }

    case intValue: IntegerValueV1 => {

        ?newValue@valueIndex knora-base:valueHasInteger @intValue.ival ;
                             knora-base:valueHasString """@intValue.ival.toString""" .

    }

    case floatValue: FloatValueV1 => {

        ?newValue@valueIndex knora-base:valueHasFloat @floatValue.fval ;
                             knora-base:valueHasString """@floatValue.fval.toString""" .

    }

    case jdcValue: JulianDayCountValueV1 => {

        ?newValue@valueIndex knora-base:valueHasStartJDC @jdcValue.dateval1 ;
                             knora-base:valueHasEndJDC @jdcValue.dateval2 ;
                             knora-base:valueHasStartPrecision "@jdcValue.dateprecision1" ;
                             knora-base:valueHasEndPrecision "@jdcValue.dateprecision2" ;
                             knora-base:valueHasCalendar "@jdcValue.calendar" ;
                             knora-base:valueHasString """@jdcValue.toString""" .

    }

    case colorValue: ColorValueV1 => {

        ?newValue@valueIndex knora-base:valueHasColor """@colorValue.color""" ;
                             knora-base:valueHasString """@colorValue.toString""" .

    }

    case geometryValue: GeomValueV1 => {

        ?newValue@valueIndex knora-base:valueHasGeometry """@geometryValue.geom""" ;
                             knora-base:valueHasString """@geometryValue.toString""" .

    }

    case stillImageFileValue: StillImageFileValueV1 => {
        ?newValue@valueIndex knora-base:originalFilename """@stillImageFileValue.originalFilename""" ;
                             knora-base:originalMimeType """@stillImageFileValue.originalMimeType""" ;
                             knora-base:internalFilename """@stillImageFileValue.internalFilename""" ;
                             knora-base:internalMimeType """@stillImageFileValue.internalMimeType""" ;
                             knora-base:dimX @stillImageFileValue.dimX ;
                             knora-base:dimY @stillImageFileValue.dimY ;
                             knora-base:qualityLevel @stillImageFileValue.qualityLevel ;
                             knora-base:valueHasQname """@stillImageFileValue.qualityName""" .

        @if(stillImageFileValue.isPreview) {
            ?newValue@valueIndex knora-base:valueIsPreview true .
        }

        ?newValue@valueIndex knora-base:valueHasString """@stillImageFileValue.toString""" .
    }

    case other => {
        @{throw SparqlGenerationException(s"Value object $other is not supported in this SPARQL template"); ()}
    }
}

@* TODO: add remaining types. *@

@* Insert the value's comment, if given. *@
@maybeComment match {
    case Some(comment) => {
        ?newValue@valueIndex knora-base:valueHasComment """@comment""" .
    }

    case None => {}
}

@* Insert the value's permission-relevant assertions (its owner, project, and permissions). *@
@for(assertion <- permissionRelevantAssertions) {
    ?newValue@valueIndex <@assertion._1> <@assertion._2> .
}

?newValue@valueIndex knora-base:valueHasOrder ?nextOrder ;
                     knora-base:valueCreationDate ?currentTime .

@* Insert direct links and LinkValues for resource references. *@

@for((linkUpdate, linkValueIndex) <- linkUpdates.zipWithIndex) {
    @* Insert a direct link for the resource reference if necessary. *@
    @if(linkUpdate.insertDirectLink) {
        ?resource <@linkUpdate.linkPropertyIri> <@linkUpdate.linkTargetIri> .
    }

    @* Insert a LinkValue for the resource reference. *@
    <@linkUpdate.newLinkValueIri> rdf:type knora-base:LinkValue ;
        rdf:subject ?resource ;
        rdf:predicate <@linkUpdate.linkPropertyIri> ;
        rdf:object <@linkUpdate.linkTargetIri> ;
        knora-base:valueHasRefCount @linkUpdate.newReferenceCount ;
        knora-base:valueCreationDate ?currentTime .

    @for(assertion <- linkUpdate.permissionRelevantAssertions) {
        <@linkUpdate.newLinkValueIri> <@assertion._1> <@assertion._2> .
    }

    @* If we're inserting a new version of an existing LinkValue, attach it to the previous version. *@
    @if(linkUpdate.linkValueExists) {
        <@linkUpdate.newLinkValueIri> knora-base:previousValue ?linkValue@linkValueIndex .
    }

    @* Attach the new LinkValue to its containing resource. *@
    ?resource <@{linkUpdate.linkPropertyIri}Value> <@linkUpdate.newLinkValueIri> .
}

@* Attach the value to the resource. *@
?resource ?property@valueIndex ?newValue@valueIndex .
